Properly understanding the relationships between API GW APIs, custom domain names, resources, stages, 
and deployments is essential to working with this repo, but the AWS documentation is obscure.

# APIs

Our API GW configuration revolves around two “API” control objects, one each for prod and stage. 
Once you select one of those on the AWS API GW console UI, the UI offers various derivative configuration 
objects for the API on the leftmost panel. Most of the concepts that follow pertain to these 
derivative configuration objects.

Please note that based on discussion that follows, having two API control objects is redundant – the 
resource specification for the two ends up being the same, and a single API control object would have done 
the trick. It’s possible that this was an oversight, but it’s also possible that from an operational 
perspective it’s a safer approach, as it keeps all-important “stage” configuration objects separate on 
the AWS console, making it harder to inadvertently fat-finger changes on one environment intended for the other.

# Custom domain names

By default, the API GW listens to unfriendly domain names generated by AWS. The Gateway allows you to provide 
friendlier aliases for these domain names. These are the so-called custom domain names.

Our API GW configuration uses one custom domain name per API control object. To see the association, start 
from a custom domain name on the API GW console and find the domain’s API via the domain’s API mapping.

The API Gateway’s custom domain names have been preset by earlier edX users, and are api.edx.org for 
the prod environment and api.stage.edx.org for the stage environment.

# API GW Resources

As mentioned above, the API GW configuration is with two named APIs, one per environment. Thus, each of these 
“APIs” is an aggregate API, including all endpoints for all 2U teams offering capabilities via the API Gateway. 
That aggregate API is defined in the api_manager swagger/api.yaml file. This file maps into an API GW “Resource” 
object, and is parameterized in the sense that the resource specification is in terms of variables whose values 
are assigned externally. This allows a single resource specification to be reused across all environments.

Changing the Resources object for an API GW API does not change the gateway’s live behavior. 
The live behavior only changes when an updated resources object is deployed. (See more on this in 
the deployment note below).

Managing public APIs on the API gateway entails modifying the swagger/api.yaml file by adding or changing 
endpoints. So long as you don't subtract anything from the previous version of this file, others' APIs will 
continue to be offered without change.

# Deployments

The term “deployment” as used by the API GW means to different things depending on how it is used. 
When used to mean “AWS deployment control objects referenced on the AWS console”, it has a very narrow meaning. 
Specifically, it means a timestamped version of an API resource specification. When used to mean the result of 
deploying an API, it’s meaning broadens to include ancillary configuration objects required to fully specify 
API GW behavior with the selected API resources.

Because resource specifications are parameterized, they are incomplete without parameter values. These 
are supplied by API GW “stage” configuration objects. The act of deploying an API gateway API requires that a 
stage (new or existing) be selected to govern how the endpoints being deployed map to backend hosts, per the 
variable values defined on the selected stage configuration object.

New deployment objects are created whenever the set of supported endpoints or their syntax changes.

An API gateway API can be re-deployed even if no change has been made to its associated deployment object. 
This occurs, for example, when standing up a new environment, or  when changing endpoint behavior by delegating 
to new back-end hosts. More on this follows in the section on Stages.

You discover which deployment is active on an environment by:
- Select your environment’s custom domain
- Select the API mappings tab
- Click on the stage link (this is the “live” stage)
- Select the “Deployment history” tab
- Scroll up and down until you find the deployment with the “Current stage” column checkmarked

# Stages

A “Stage” configuration object contains the ancillary configuration selections needed for an API deployment to 
go live. This includes operationalization selections for the API Gateway (e.g., request throttling selections), 
as well as URLs for the gateway to delegate to on receipt of endpoint requests. It is the latter that makes a 
stage configuration object environment-specific: one stage object can delegate to platform hosts running production 
code, while a different stage object can delegate to platform hosts running stage environment code.

Multiple stage objects may be associated with a single deployment control object. That’s because the 
deployment control objects is just a timestamped, parameterized resource specification. You’ll then have 
one deployment for a particular version of the supported APIs, and one stage object per environment running that API.

You discover which deployment each stage object corresponds to on the AWS console by:

-  selecting an API object
- electing its “Stages” view
- selecting a stage
- selecting the deployment history tab
- scrolling up and down until you find the deployment with the “Current stage” column checkmarked.
